---
title: "Analysis-SocCult"
output: html_document
editor_options: 
  chunk_output_type: console
---

### Packages + Functions
```{r setup, include=FALSE}
pacman::p_load(
  rethinking,
  brms,
  tidyverse,
  bayesplot,
  viridis,
  dplyr,
  data.table,
  ggplot2,
  BayesCombo
)

```


### Preprocessing 
```{r}

### EMPATHY DATA ###

# load data with empathy 
d1 <- read_csv("DATA/data.csv")

d1[1,1]

# reversing values for items 1,2,17,29 
d1[,c(10,11,26,38)] =  5 - d1[,c(10,11,26,38)]

# cognitive empathy score: 1,3,4,5,6,15,16,18,19,20,21,22,24,25,26,27,28,30,31
d1$cogemp <- rowSums(d1[, c(10,12:15,24,25,27:31,33:37,39,40)])

# affective empathy score: 2,7,8,9,10,11,12,13,14,17,23,29
d1$affemp <- rowSums(d1[, c(11,16:23,26,32,38)])

# total empathy score 
d1$totalemp <- d1$cogemp + d1$affemp

# gender
d1$gender <- ifelse(d1$`sex:1` == 1, "M", "F")


# language + siblings
d1$native <- NA
d1$siblings <- NA
for(i in 1:nrow(d1)){
  d1$native[i] <- as.character(ifelse(d1[i,4] == 1, "danish",
                     ifelse(d1[i,4] == 2, "english",
                            ifelse(d1[i,4] == 3, "german",
                                   d1[i,5]))))
  d1$siblings[i] <- as.character(ifelse(d1[i,6] == 5, d1[i,7], d1[i,6]))
}

# rename age
names(d1)[2] <- "age"

# remove s.
d1$participant <- gsub("s.", "", d1$participant)

# subset
emp <- d1[, c("participant", "gender", "age", "native", "siblings", "cogemp", "affemp", "totalemp")]

#remove NA rows
#19,22,24,27,37,39
emp <- emp[-c(19,22,24,27,37,38,39), ]


### DPT DATA ###

# load participant files
all_paths <-
  list.files(path = "~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/DATA",
             pattern = "^DPT.*.txt",
             full.names = TRUE)

all_paths


# read all the files
all_content <-
  all_paths %>%
  lapply(read.table,
         quote="\"", 
         comment.char="")

# read all the filenames
all_filenames <- all_paths %>%
  basename() %>%
  as.list()

# combine all files + filename lists
all_lists <- mapply(c, all_content, all_filenames, SIMPLIFY = FALSE)
all_result <- rbindlist(all_lists, fill = T) 

# change column name
names(all_result) <- c("block", "stimuli", "condition", "direction", "self", "other", "consistency", "cue", "correctresponse", "response", "accuracy", "RT", "participant")

# remove stuff from columns to merge
#function
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}
all_result$participant <- substrRight(all_result$participant, 40)

#recode responses and accuracy
all_result$correctresponse <- ifelse(all_result$correctresponse == 1, "yes", "no")
all_result$response <- ifelse(all_result$response == 1, "yes", "no")
all_result$response <- ifelse(all_result$accuracy == 3, "late", all_result$response)
all_result$accuracy <- ifelse(all_result$accuracy == 1, "correct", ifelse(all_result$accuracy == 2, "incorrect", "late"))


### COMBINE DATA ###

# merge all together
d <- merge(emp, all_result)
# add ID
d$ID <- d %>% group_indices(participant)
# move ID to first place
d <- d[,c(21, 2:20, 1)]

write_csv(d,"~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/FINAL_DATA.csv")
```


### Explore Data
```{r}
d <- read.csv("~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/FINAL_DATA.csv")
class(d)

# turn ID into factor
d$ID <- as.factor(d$ID)

# check if any NA's
d[!complete.cases(d), ]

summary(d)

y <- subset(d, response == "yes")
n <- subset(d, response == "no")
c <- subset(d, accuracy == "correct")
cy <- subset(c, response == "yes")

ggplot(yes, aes(x = ID, y = RT, fill = consistency)) + 
         geom_bar(stat = "summary", fun.y = "mean", position = "dodge")

ggplot(yes, aes(x = affemp, y = RT, fill = consistency)) + 
         geom_bar(stat = "summary", fun.y = "mean", position = "dodge")

ggplot(no, aes(x = ID, fill = accuracy, color = consistency)) + 
         geom_bar(position = "dodge")
```


#Analysis Functions
```{r}

# Functions for RT models
RT_FancyFunction <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # prior test
  RT_prior <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(RT_prior, nsamples = 1000)
 
  # run model
  RT_m <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
  
  # summary/quality check
  summary <- summary(RT_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(RT_m, nsamples = 1000)
  
  #add loo 
  RT_m <- add_criterion(RT_m, criterion = c("bayes_R2", "loo"), reloo = T)
  
  #return
  all <- list("prior_check" = ppc1, 
              "model" = RT_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}
RT_Prior_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # prior test
  RT_prior <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(RT_prior, nsamples = 1000)
 
  #return
  return(ppc1)
}
RT_Model_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # run model
  RT_m <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
  
  # summary/quality check
  summary <- summary(RT_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(RT_m, nsamples = 1000)
  
  #add loo 
  RT_m <- add_criterion(RT_m, criterion = c("bayes_R2", "loo"), reloo = T)
  
  #return
  all <- list("model" = RT_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}


# Functions for Error models
Error_FancyFunction <- function(formula, data, prior, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # prior test
  Error_prior <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(Error_prior, nsamples = 1000)
 
  # run model
  Error_m <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)

  # summary/quality check
  summary <- summary(Error_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(Error_m, nsamples = 1000)
  
  #add loo 
  Error_m <- add_criterion(Error_m, criterion = c("bayes_R2", "loo"), reloo = T)
  
  #return
  all <- list("prior_check" = ppc1, 
              "model" = RT_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}
Error_Prior_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # prior test
  Error_prior <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(Error_prior, nsamples = 1000)
 
  #return
  return(ppc1)
}
Error_Model_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # run model
  Error_m <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
  
  # summary/quality check
  summary <- summary(Error_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(Error_m, nsamples = 1000)
  
  #add loo 
  Error_m <- add_criterion(Error_m, criterion = c("bayes_R2", "loo"), reloo = T)
  
  #return
  all <- list("model" = Error_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}

```


#RT - Defining Models
```{r}

### Multilevel Models
# Baseline model
RT_f0 <- bf(RT|trunc(ub = 2000) ~ 1 + (1|ID))

# Consistency, simple varying effect
RT_f1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1|ID))
# Consistency, complex varying effect
RT_f1.1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1 + consistency|ID))

# Consistency + Condition, simple varying effect
RT_f2 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1|ID))
# Consistency + Condition, complex varying effect
RT_f2.1 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1 + condition + consistency|ID))

# Interaction, simple varying effect
RT_f3 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (1|ID))
# Interaction, complex varying effect
RT_f3.1 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

```

#RT - F0
```{r}

RT_f0 <- bf(RT|trunc(ub = 2000) ~ 1 + (1|ID))

get_prior(RT_f0, cy, family = shifted_lognormal())

RT_prior_f0 <- c(
  prior(normal(6.3, 0.1), class = Intercept), 
  prior(normal(0, .1), class = sigma),
  prior(normal(0, .1), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m0 <- RT_Prior_Function(formula = RT_f0, prior = RT_prior_f0, data = cy, chain_nr = 2, iter_nr = 2000)
RT_m0 <- RT_Model_Function(formula = RT_f0, prior = RT_prior_f0, data = cy)

RT_m0$summary
RT_m0$mcmc_trace
RT_m0$mcmc_ranktrace
RT_m0$posterior_check

#predictions
predictions_m0 <- predict(RT_m0)
predictions_m0
mean(predictions_m0)
sd(predictions_m0)

#hypothesis testing
plot(hypothesis(RT_m0$model,"Intercept > 0"))
plot(hypothesis(RT_m0$model, "Intercept > 0", class = "sd", group = "ID"))

#prior posterior plot for sigma
prior0 <- prior_samples(RT_m0$model)
post0 <- posterior_samples(RT_m0$model)
plot(density(prior0$sigma), ylim=c(1,40), lty = 3)
lines(density(post0$sigma), lty = 1)

```


#RT - F1
```{r}
# Consistency, simple varying effect
RT_f1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1|ID))

get_prior(RT_f1, cy, family = shifted_lognormal())

RT_prior_f1 <- c(
  prior(normal(6.3, 0.1), class = Intercept), 
  prior(normal(0, .1), class = sigma),
  prior(normal(0, .1), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m1 <- RT_Prior_Function(formula = RT_f1, prior = RT_prior_f1, data = cy, chain_nr = 2, iter_nr = 2000)
RT_m1 <- RT_Model_Function(formula = RT_f1, prior = RT_prior_f1, data = cy)

RT_m1$summary
RT_m1$mcmc_trace
RT_m1$mcmc_ranktrace
RT_m1$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m1,"Intercept > 0"))
plot(hypothesis(RT_m1,"consistencyincon > 0"))
plot(hypothesis(RT_m1, "Intercept > 0", class = "sd", group = "ID"))
```


#RT - F1.1
```{r}
# Consistency, complex varying effect
RT_f1.1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1 + consistency|ID))

#same prior as model 1
RT_prior_m1.1 <- RT_Prior_Function(formula = RT_f1.1, prior = RT_prior_f1, data = cy)
RT_m1.1 <- RT_Model_Function(formula = RT_f1.1, prior = RT_prior_f1, data = cy)

RT_m1.1$summary
RT_m1.1$mcmc_trace
RT_m1.1$mcmc_ranktrace
RT_m1.1$posterior_check
```


#RT - F2
```{r}
# Consistency + Condition, simple varying effect
RT_f2 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1|ID))

get_prior(RT_f2, cy, family = shifted_lognormal())

RT_prior_f2 <- c(
  prior(normal(6.3, 0.1), class = Intercept), 
  prior(normal(0, .1), class = sigma),
  prior(normal(0, .1), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m2 <- RT_Prior_Function(formula = RT_f2, prior = RT_prior_f2, data = cy)
RT_m2 <- RT_Model_Function(formula = RT_f2, prior = RT_prior_f2, data = cy)

RT_m2$summary
RT_m2$mcmc_trace
RT_m2$mcmc_ranktrace
RT_m2$posterior_check
```


#RT - F2.1
```{r}
# Consistency + Condition, simple varying effect
RT_f2.1 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1 + condition + consistency|ID))

#same prior as model 2
RT_prior_m2.1 <- RT_Prior_Function(formula = RT_f2.1, prior = RT_prior_f2, data = cy)
RT_m2.1 <- RT_Model_Function(formula = RT_f2.1, prior = RT_prior_f2, data = cy)

RT_m2.1$summary
RT_m2.1$mcmc_trace
RT_m2.1$mcmc_ranktrace
RT_m2.1$posterior_check
```


#RT - F3
```{r}
# Interaction, simple varying effect
RT_f3 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (1|ID))

get_prior(RT_f3, cy, family = shifted_lognormal())

RT_prior_f3 <- c(
  prior(normal(6.3, 0.1), class = Intercept), 
  prior(normal(0, .1), class = sigma),
  prior(normal(0, .1), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m3 <- RT_Prior_Function(formula = RT_f3, prior = RT_prior_f3, data = cy)
RT_m3 <- RT_Model_Function(formula = RT_f3, prior = RT_prior_f3, data = cy)

RT_m3$summary
RT_m3$mcmc_trace
RT_m3$mcmc_ranktrace
RT_m3$posterior_check
```


#RT - F3.1
```{r}
# Interaction, complex varying effect
RT_f3.1 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

#same prior as model 3
RT_prior_m3.1 <- RT_Prior_Function(formula = RT_f3.1, prior = RT_prior_f3, data = cy)
RT_m3.1 <- RT_Model_Function(formula = RT_f3.1, prior = RT_prior_f3, data = cy)

RT_m3.1$summary
RT_m3.1$mcmc_trace
RT_m3.1$mcmc_ranktrace
RT_m3.1$posterior_check
```


#RT - Model Comparison
```{r}

#comparing out of sample error
loo_compare(RT_m0, RT_m1, RT_m1.1, RT_m2, RT_m2.1, RT_m3, RT_m3.1)

#stacking weights
loo_model_weights(RT_m0, RT_m1, RT_m1.1, RT_m2, RT_m2.1, RT_m3, RT_m3.1)

```


#Error - Defining Models
```{r}

### Multilevel Models
# Baseline model
E_f0 <- bf(accuracy ~ 1 + (1|ID))

# Consistency, simple varying effect
E_f1 <- bf(accuracy ~ 1 + consistency + (1|ID))
# Consistency, complex varying effect
E_f1.1 <- bf(accuracy ~ 1 + consistency + (1 + consistency|ID))

# Consistency + Condition, simple varying effect
E_f2 <- bf(accuracy ~ 1 + condition + consistency + (1|ID))
# Consistency + Condition, complex varying effect
E_f2.1 <- bf(accuracy ~ 1 + condition + consistency + (1 + condition + consistency|ID))

# Interaction, simple varying effect
E_f3 <- bf(accuracy ~ 0 + condition + condition : consistency + (1|ID))
# Interaction, complex varying effect
E_f3.1 <- bf(accuracy ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

```


#Error - F0 
```{r}
E_f0 <- bf(accuracy ~ 1 + (1|ID))

get_prior(E_f0, y, family = bernoulli())

E_prior_f0 <- c(
  prior(normal(0, 1.5), class = Intercept))

E_prior_m0 <- Error_Prior_Function(formula = E_f0, prior = E_prior_f0, data = y)
E_m0 <- Error_Model_Function(formula = E_f0, prior = E_prior_f0, data = y)

E_m0$summary
E_m0$mcmc_trace
E_m0$mcmc_ranktrace
E_m0$posterior_check

```


#Error - F1
```{r}
E_f1 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f1, y, family = bernoulli())

E_prior_f1 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m1 <- Error_Prior_Function(formula = E_f1, prior = E_prior_f1, data = y)
E_m1 <- Error_Model_Function(formula = E_f1, prior = E_prior_f1, data = y)

E_m1$summary
E_m1$mcmc_trace
E_m1$mcmc_ranktrace
E_m1$posterior_check

```


#Error - F1.1
```{r}
E_f1.1 <- bf(accuracy ~ 1 + consistency + (1|ID))

# same prior as in f1
E_prior_m1.1 <- Error_Prior_Function(formula = E_f1.1, prior = E_prior_f1, data = y)
E_m1.1 <- Error_Model_Function(formula = E_f1.1, prior = E_prior_f1, data = y)

E_m1.1$summary
E_m1.1$mcmc_trace
E_m1.1$mcmc_ranktrace
E_m1.1$posterior_check

```


#Error - F2
```{r}
E_f2 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f2, y, family = bernoulli())

E_prior_f2 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m2 <- Error_Prior_Function(formula = E_f2, prior = E_prior_f2, data = y)
E_m2 <- Error_Model_Function(formula = E_f2, prior = E_prior_f2, data = y)

E_m2$summary
E_m2$mcmc_trace
E_m2$mcmc_ranktrace
E_m2$posterior_check

```


#Error - F2.1
```{r}
E_f2.1 <- bf(accuracy ~ 1 + consistency + (1|ID))

# same prior as in f2
E_prior_m2.1 <- Error_Prior_Function(formula = E_f2.1, prior = E_prior_f2.1, data = y)
E_m2.1 <- Error_Model_Function(formula = E_f2.1, prior = E_prior_f2.1, data = y)

E_m2.1$summary
E_m2.1$mcmc_trace
E_m2.1$mcmc_ranktrace
E_m2.1$posterior_check

```


#Error - F3
```{r}
E_f3 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f3, y, family = bernoulli())

E_prior_f3 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m3 <- Error_Prior_Function(formula = E_f3, prior = E_prior_f3, data = y)
E_m3 <- Error_Model_Function(formula = E_f3, prior = E_prior_f3, data = y)

E_m3$summary
E_m3$mcmc_trace
E_m3$mcmc_ranktrace
E_m3$posterior_check

```


#Error - F3.1
```{r}
E_f3.1 <- bf(accuracy ~ 1 + consistency + (1|ID))

# same prior as in f3
E_prior_m3.1 <- Error_Prior_Function(formula = E_f3.1, prior = E_prior_f3.1, data = y)
E_m3.1 <- Error_Model_Function(formula = E_f3.1, prior = E_prior_f3.1, data = y)

E_m3.1$summary
E_m3.1$mcmc_trace
E_m3.1$mcmc_ranktrace
E_m3.1$posterior_check

```


#Error - Model Comparison
```{r}

#comparing out of sample error
loo_compare(E_m0, E_m1, E_m1.1, E_m2, E_m2.1, E_m3, E_m3.1)

#stacking weights
loo_model_weights(E_m0, E_m1, E_m1.1, E_m2, E_m2.1, E_m3, E_m3.1)

```


#Empathy
```{r}
#scale empathy! 
d$totalemp <- scale(d$totalemp)
d$cogemp <- scale(d$cogemp)
d$affemp <- scale(d$affemp)

#possible models
#total empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:totalemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:totalemp + (varying effects))

#cognitive empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:cogemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:cogemp + (varying effects))

#affective empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:affemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:affemp + (varying effects))


#and only test one parameter
#conditionAvatar:Consistency1:Empathy
#conditionAvatar:Consistency1:Empathy > conditionArrows:Consistency1:Empathy


#other option: 
#extract posterior of varying effects from h1, for each participant you get n samples of the score for the slope of consistency within the avatar condition (you can ignore the other varying effects). You run a model predicting this score from the empathy score (making sure to tell the model that the different samples cluster under ID).

var_eff <- ranef(RT_m3.1$model, summary = F)

var_eff_m <- vareff ~ totalemp 

#bf(vareff ~ 1 + totalemp + (1|gr(ID, by = totalemp))
#bf(vareff ~ 0 + totalemp + (1|gr(ID, by = totalemp))



```

