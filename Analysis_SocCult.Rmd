---
title: "Analysis-SocCult"
output: html_document
editor_options: 
  chunk_output_type: console
---

### Packages + Functions
```{r setup, include=FALSE}
pacman::p_load(
  rethinking,
  brms,
  tidyverse,
  bayesplot,
  viridis,
  dplyr,
  data.table,
  ggplot2,
  BayesCombo,
  patchwork,
  beepr,
  graphics
)

```


### Preprocessing 
```{r}

### EMPATHY DATA ###

# load data with empathy 
d1 <- read_csv("DATA/data.csv")

d1[1,1]

# reversing values for items 1,2,17,29 
d1[,c(10,11,26,38)] =  5 - d1[,c(10,11,26,38)]

# cognitive empathy score: 1,3,4,5,6,15,16,18,19,20,21,22,24,25,26,27,28,30,31
d1$cogemp <- rowSums(d1[, c(10,12:15,24,25,27:31,33:37,39,40)])

# affective empathy score: 2,7,8,9,10,11,12,13,14,17,23,29
d1$affemp <- rowSums(d1[, c(11,16:23,26,32,38)])

# total empathy score 
d1$totalemp <- d1$cogemp + d1$affemp

# gender
d1$gender <- ifelse(d1$`sex:1` == 1, "M", "F")


# language + siblings
d1$native <- NA
d1$siblings <- NA
for(i in 1:nrow(d1)){
  d1$native[i] <- as.character(ifelse(d1[i,4] == 1, "danish",
                     ifelse(d1[i,4] == 2, "english",
                            ifelse(d1[i,4] == 3, "german",
                                   d1[i,5]))))
  d1$siblings[i] <- as.character(ifelse(d1[i,6] == 5, d1[i,7], d1[i,6]))
}

# rename age
names(d1)[2] <- "age"

# remove s.
d1$participant <- gsub("s.", "", d1$participant)

# subset
emp <- d1[, c("participant", "gender", "age", "native", "siblings", "cogemp", "affemp", "totalemp")]

#remove NA rows
#19,22,24,27,37,39
emp <- emp[-c(19,22,24,27,37,38,39), ]


### DPT DATA ###

# load participant files
all_paths <-
  list.files(path = "~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/DATA",
             pattern = "^DPT.*.txt",
             full.names = TRUE)

all_paths


# read all the files
all_content <-
  all_paths %>%
  lapply(read.table,
         quote="\"", 
         comment.char="")

# read all the filenames
all_filenames <- all_paths %>%
  basename() %>%
  as.list()

# combine all files + filename lists
all_lists <- mapply(c, all_content, all_filenames, SIMPLIFY = FALSE)
all_result <- rbindlist(all_lists, fill = T) 

# change column name
names(all_result) <- c("block", "stimuli", "condition", "direction", "self", "other", "consistency", "cue", "correctresponse", "response", "accuracy", "RT", "participant")

# remove stuff from columns to merge
#function
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}
all_result$participant <- substrRight(all_result$participant, 40)

#recode responses and accuracy
all_result$correctresponse <- ifelse(all_result$correctresponse == 1, "yes", "no")
all_result$response <- ifelse(all_result$response == 1, "yes", "no")
all_result$response <- ifelse(all_result$accuracy == 3, "late", all_result$response)
all_result$accuracy <- ifelse(all_result$accuracy == 1, "correct", ifelse(all_result$accuracy == 2, "incorrect", "late"))


### COMBINE DATA ###

# merge all together
d <- merge(emp, all_result)
# add ID
d$ID <- d %>% group_indices(participant)
# move ID to first place
d <- d[,c(21, 2:20, 1)]

write_csv(d,"~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/FINAL_DATA.csv")
```


### Explore Data
```{r}
d <- read.csv("~/Documents/University/4SEMESTER/Social and Cultural Dynamics/EXAM/ANALYSIS/SocCult-Exam/FINAL_DATA.csv")
class(d)

# turn ID into factor
d$ID <- as.factor(d$ID)

# check if any NA's
d[!complete.cases(d), ]

# add log values and log
d$RT_log <- log(d$RT)
summary(d$RT_log)

# add log - ndt for summary 
d$RT_log_ndt <- log(d$RT - 200)
summary(d$RT_log_ndt)

# summary 
summary(d)

# make seperate subsets
y <- subset(d, correctresponse == "yes" & accuracy != "late") #6 late rows removed 
n <- subset(d, correctresponse == "no")
c <- subset(d, accuracy == "correct")
cy <- subset(c, correctresponse == "yes")

ggplot(yes, aes(x = ID, y = RT, fill = consistency)) + 
         geom_bar(stat = "summary", fun.y = "mean", position = "dodge")

ggplot(yes, aes(x = affemp, y = RT, fill = consistency)) + 
         geom_bar(stat = "summary", fun.y = "mean", position = "dodge")

ggplot(no, aes(x = ID, fill = accuracy, color = consistency)) + 
         geom_bar(position = "dodge")

mean(RT_log_ndt)
mean()

# calculating sd and mean by of ID means
mean_RT_log <- cy %>% 
  group_by(ID) %>% 
  summarise(mean = mean(RT_log_ndt))

sd(mean_RT_log$mean)

summary(mean_RT_log$mean)

```


#Analysis Functions
```{r}

# Functions for RT models
RT_Prior_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3, samples = 1000){
  
  # prior test
  RT_prior <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(RT_prior, nsamples = samples)
  
   beep(sound = 10)
 
  #return
  return(ppc1)
  
}

RT_Model_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # run model
  RT_m <- brm(
  formula,
  data,
  family = shifted_lognormal(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
  
  # summary/quality check
  summary <- summary(RT_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(RT_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(RT_m, nsamples = 1000)
  
  #add loo 
  RT_m <- add_criterion(RT_m, criterion = c("loo"), reloo = T)
  
    beep(sound = 10)
  
  #return
  all <- list("model" = RT_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}


# Functions for Error models
Error_Prior_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # prior test
  Error_prior <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = "only",
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr)
 
  # prior check
  ppc1 <- pp_check(Error_prior, nsamples = 1000)
  
  all <- list("model" = Error_prior,
              "ppc" = ppc1)
 
  beep(sound = 10)
  #return
  return(all)
}

Error_Model_Function <- function(formula, prior, data, chain_nr = 4, iter_nr = 4000, core_nr = 3){
  
  # run model
  Error_m <- brm(
  formula,
  data,
  family = bernoulli(),
  prior = prior,
  sample_prior = T,
  seed = 28,
  chains = chain_nr,
  cores = core_nr,
  iter = iter_nr,
  control = list(
    adapt_delta=0.99,
    max_treedepth = 20))
  
  # summary/quality check
  summary <- summary(Error_m) 
  
  #MCMC trace and rank trace plots
  color_scheme_set("viridis")
  mcmc1 <- mcmc_trace(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  mcmc2 <- mcmc_rank_overlay(Error_m, pars = vars(-contains("["), -contains("prior"), -contains("lp"))) + theme_classic()
  
  # posterior checks 
  ppc2 <- pp_check(Error_m, nsamples = 1000)
  
  #add loo 
  Error_m <- add_criterion(Error_m, criterion = c("bayes_R2", "loo"), reloo = T)
  
  beep(sound = 10)
  #return
  all <- list("model" = Error_m,
              "summary" = summary,
              "mcmc_trace" = mcmc1,
              "mcmc_ranktrace" = mcmc2,
              "posterior_check" = ppc2)
  return(all)
}

```


#RT - Defining Models
```{r}

### Multilevel Models
# Baseline model
RT_f0 <- bf(RT|trunc(ub = 2000) ~ 1 + (1|ID))

# Consistency, simple varying effect
RT_f1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1|ID))
# Consistency, complex varying effect
RT_f1.1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1 + consistency|ID))

# Consistency + Condition, simple varying effect
RT_f2 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1|ID))
# Consistency + Condition, complex varying effect
RT_f2.1 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1 + condition + consistency|ID))

# Interaction, simple varying effect
RT_f3 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (1|ID))
# Interaction, complex varying effect
RT_f3.1 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

```

#RT - F0
```{r}

RT_f0 <- bf(RT|trunc(ub = 2000) ~ 1 + (1|ID))

get_prior(RT_f0, cy, family = shifted_lognormal())

min(cy$RT)

RT_prior_f0 <- c(
  prior(normal(6.3, 0.2), class = Intercept), 
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m0 <- RT_Prior_Function(formula = RT_f0, prior = RT_prior_f0, data = cy)
RT_m0 <- RT_Model_Function(formula = RT_f0, prior = RT_prior_f0, data = cy)

RT_m0$model  
RT_m0$summary
RT_m0$mcmc_trace
RT_m0$mcmc_ranktrace
RT_m0$posterior_check

#predictions
predictions_m0 <- predict(RT_m0)
mean(predictions_m0)
sd(predictions_m0)

#hypothesis testing
plot(hypothesis(RT_m0$model,"Intercept > 0"))
plot(hypothesis(RT_m0$model, "Intercept > 0", class = "sd", group = "ID"))

#prior-posterior for intercept
prior0 <- prior_samples(RT_m0$model)
post0 <- posterior_samples(RT_m0$model)
plot(density(prior0$Intercept), ylim=c(0,9), lty = 3, main = "RT_M0: Posterior and prior distribution for the intercept")
lines(density(post0$b_Intercept), lty = 1)

#prior-posterior plot for sigma
prior0 <- prior_samples(RT_m0$model)
post0 <- posterior_samples(RT_m0$model)
plot(density(prior0$sigma), ylim=c(0,40), lty = 3, main = "RT_M0: Posterior and prior distribution for sigma")
lines(density(post0$sigma), lty = 1)

```


#RT - F1
```{r}
# Consistency, simple varying effect
RT_f1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1|ID))

get_prior(RT_f1, cy, family = shifted_lognormal())

RT_prior_f1 <- c(
  prior(normal(6.3, 0.2), class = Intercept), 
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = b),
  prior(normal(0, 0.2), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m1 <- RT_Prior_Function(formula = RT_f1, prior = RT_prior_f1, data = cy)
RT_m1 <- RT_Model_Function(formula = RT_f1, prior = RT_prior_f1, data = cy)

RT_m1$summary
RT_m1$mcmc_trace
RT_m1$mcmc_ranktrace
RT_m1$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m1$model,"Intercept > 0"))
plot(hypothesis(RT_m1$model,"consistencyincon > 0"))
plot(hypothesis(RT_m1$model, "Intercept > 0", class = "sd", group = "ID"))

#prior-posterior for intercept
prior1 <- prior_samples(RT_m1$model)
post1 <- posterior_samples(RT_m1$model)
plot(density(prior1$Intercept), ylim=c(0,9), lty = 3, main = "RT_M1: Posterior and prior distribution for the intercept")
lines(density(post1$b_Intercept), lty = 1)

#prior-posterior plot for sigma
prior1 <- prior_samples(RT_m1$model)
post1 <- posterior_samples(RT_m1$model)
plot(density(prior1$sigma), ylim=c(0,40), lty = 3, main = "RT_M1: Posterior and prior distribution for sigma")
lines(density(post1$sigma), lty = 1)

```


#RT - F1.1
```{r}

ggplot(cy, aes(x=consistency, y=RT, color=ID)) + 
  stat_summary(aes(group = ID), fun.y = mean, geom = 'line', size=0.5, alpha=0.9)

# Consistency, complex varying effect
RT_f1.1 <- bf(RT|trunc(ub = 2000) ~ 1 + consistency + (1 + consistency|ID))

get_prior(RT_f1.1, cy)

RT_prior_f1.1 <- c(
  prior(normal(6.3, 0.2), class = Intercept), 
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = b),
  prior(normal(0, 0.2), class = sd),
  prior(lkj(1), class = cor)#not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m1.1 <- RT_Prior_Function(formula = RT_f1.1, prior = RT_prior_f1.1, data = cy)
RT_m1.1 <- RT_Model_Function(formula = RT_f1.1, prior = RT_prior_f1.1, data = cy)

RT_m1.1$summary
RT_m1.1$mcmc_trace
RT_m1.1$mcmc_ranktrace
RT_m1.1$posterior_check


## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m1.1$model,"Intercept > 0"))
plot(hypothesis(RT_m1.1$model,"consistencyincon > 0"))
plot(hypothesis(RT_m1.1$model, "Intercept > 0", class = "sd", group = "ID"))
plot(hypothesis(RT_m1.1$model, "consistencyincon > 0", class = "sd", group = "ID"))
plot(hypothesis(RT_m1.1$model, "Intercept__consistencyincon = 0", class = "cor", group = "ID"))

#prior-posterior distributions
prior1.1 <- prior_samples(RT_m1.1$model)
post1.1 <- posterior_samples(RT_m1.1$model)

#prior-posterior plot for intercept
plot(density(prior1.1$Intercept), ylim=c(0,9), lty = 3, main = "RT_M1.1: Posterior and prior distribution for the intercept")
lines(density(post1.1$b_Intercept), lty = 1)

#prior-posterior plot for sigma
plot(density(prior1.1$sigma), ylim=c(0,45), lty = 3, main = "RT_M1.1: Posterior and prior distribution for sigma")
lines(density(post1.1$sigma), lty = 1)
```


#RT - F2
```{r}
# Consistency + Condition, simple varying effect
RT_f2 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1|ID))

get_prior(RT_f2, cy, family = shifted_lognormal())

RT_prior_f2 <- c(
  prior(normal(6.3, 0.2), class = Intercept), 
  prior(normal(0, 0.2), class = b),
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m2 <- RT_Prior_Function(formula = RT_f2, prior = RT_prior_f2, data = cy)

pairs(RT_prior_m2$data)


RT_m2 <- RT_Model_Function(formula = RT_f2, prior = RT_prior_f2, data = cy)

RT_m2$summary
RT_m2$mcmc_trace
RT_m2$mcmc_ranktrace
RT_m2$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m2$model,"Intercept > 0")) #intercept
plot(hypothesis(RT_m2$model,"conditionO > 0")) # beta for condition
plot(hypothesis(RT_m2$model,"consistencyincon > 0")) # beta for consistency
plot(hypothesis(RT_m2$model, "Intercept > 0", class = "sd", group = "ID")) #varyig intercept

#prior-posterior distributions
prior2 <- prior_samples(RT_m2$model)
post2 <- posterior_samples(RT_m2$model)

par(mfrow=c(2,1))

#prior-posterior plot for intercept
plot(density(prior2$Intercept), ylim=c(0,9), lty = 3, main = "RT_M2: Posterior and prior distribution for the intercept")
lines(density(post2$b_Intercept), lty = 1)

#prior-posterior plot for sigma
plot(density(prior2$sigma), ylim=c(0,40), lty = 3, main = "RT_M2: Posterior and prior distribution for sigma")
lines(density(post2$sigma), lty = 1)
```


#RT - F2.1
```{r}
# Consistency + Condition, simple varying effect
RT_f2.1 <- bf(RT|trunc(ub = 2000) ~ 1 + condition + consistency + (1 + condition + consistency|ID))

RT_prior_f2.1 <- c(
  prior(normal(6.3, 0.2), class = Intercept), 
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = b),
  prior(normal(0, 0.2), class = sd),
  prior(lkj(1), class = cor)#not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_prior_m2.1 <- RT_Prior_Function(formula = RT_f2.1, prior = RT_prior_f2.1, data = cy)
RT_m2.1 <- RT_Model_Function(formula = RT_f2.1, prior = RT_prior_f2.1, data = cy)

RT_m2.1$summary
RT_m2.1$mcmc_trace
RT_m2.1$mcmc_ranktrace
RT_m2.1$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m2.1$model,"Intercept > 0")) #intercept

plot(hypothesis(RT_m2.1$model,"conditionO > 0")) # beta for condition
plot(hypothesis(RT_m2.1$model,"consistencyincon > 0")) # beta for consistency

plot(hypothesis(RT_m2.1$model, "Intercept > 0", class = "sd", group = "ID")) #varyig intercept
plot(hypothesis(RT_m2.1$model, "conditionO > 0", class = "sd", group = "ID")) #varying slope for condition
plot(hypothesis(RT_m2.1$model, "consistencyincon > 0", class = "sd", group = "ID")) #varying slope for consistency

plot(hypothesis(RT_m2.1$model, "Intercept__conditionO > 0", class = "cor", group = "ID")) #varyig intercept
plot(hypothesis(RT_m2.1$model, "Intercept__consistencyincon > 0", class = "cor", group = "ID")) #varying slope for condition
plot(hypothesis(RT_m2.1$model, "conditionO__consistencyincon > 0", class = "cor", group = "ID")) #varying slope for consistency

#prior-posterior distributions
prior2.1 <- prior_samples(RT_m2.1$model)
post2.1 <- posterior_samples(RT_m2.1$model)

par(mfrow=c(2,1))

#prior-posterior plot for intercept
plot(density(prior2.1$Intercept), ylim=c(0,9), lty = 3, main = "RT_M2.1: Posterior and prior distribution for the intercept")
lines(density(post2.1$b_Intercept), lty = 1)

#prior-posterior plot for sigma
plot(density(prior2.1$sigma), ylim=c(0,40), lty = 3, main = "RT_M2.1: Posterior and prior distribution for sigma")
lines(density(post2.1$sigma), lty = 1)

```


#RT - F3
```{r}
# Interaction, simple varying effect
RT_f3 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (1|ID))

get_prior(RT_f3, cy, family = shifted_lognormal())

RT_prior_f3 <- c(
  prior(normal(6.3, 0.2), class = b, coef = conditionA),
  prior(normal(6.3, 0.2), class = b, coef = conditionO),
  prior(normal(0, 0.2), class = b, coef = conditionA:consistencyincon),
  prior(normal(0, 0.2), class = b, coef = conditionO:consistencyincon),
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = sd) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

RT_m3_prior <- RT_Prior_Function(formula = RT_f3, prior = RT_prior_f3, data = cy)
RT_m3 <- RT_Model_Function(formula = RT_f3, prior = RT_prior_f3, data = cy)

RT_m3$summary
RT_m3$mcmc_trace
RT_m3$mcmc_ranktrace
RT_m3$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m3$model,"conditionA > 0")) # intercept for arrow
plot(hypothesis(RT_m3$model,"conditionO > 0")) # intercept for other

plot(hypothesis(RT_m3$model,"conditionA:consistencyincon > 0")) # beta for consistency
plot(hypothesis(RT_m3$model,"conditionO:consistencyincon > 0")) # beta for consistency

plot(hypothesis(RT_m3$model,"conditionO:consistencyincon > conditionA:consistencyincon")) # beta for consistency

plot(hypothesis(RT_m3$model, "Intercept > 0", class = "sd", group = "ID")) #varyig intercept

#prior-posterior distributions
prior3 <- prior_samples(RT_m3$model)
post3 <- posterior_samples(RT_m3$model)

par(mfrow=c(1,1))

#prior-posterior plot for sigma
plot(density(prior3$sigma), ylim=c(0,40), lty = 3, main = "RT_M3: Posterior and prior distribution for sigma")
lines(density(post3$sigma), lty = 1)
```


#RT - F3.1
```{r}
# Interaction, complex varying effect
RT_f3.1 <- bf(RT|trunc(ub = 2000) ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

RT_prior_f3.1 <- c(
  prior(normal(6.3, 0.2), class = b, coef = conditionA),
  prior(normal(6.3, 0.2), class = b, coef = conditionO),
  prior(normal(0, 0.2), class = b, coef = conditionA:consistencyincon),
  prior(normal(0, 0.2), class = b, coef = conditionO:consistencyincon),
  prior(normal(0, 0.2), class = sigma),
  prior(normal(0, 0.2), class = sd),
  prior(lkj(1), class = cor) #not bigger than the effect
  # prior(normal(nn, nn), class = ndt))
)

#same prior as model 3
RT_prior_m3.1 <- RT_Prior_Function(formula = RT_f3.1, prior = RT_prior_f3.1, data = cy)
RT_m3.1 <- RT_Model_Function(formula = RT_f3.1, prior = RT_prior_f3.1, data = cy)

RT_m3.1$summary
RT_m3.1$mcmc_trace
RT_m3.1$mcmc_ranktrace
RT_m3.1$posterior_check

## Posterior update check (Has the posterior learned from the prior?)
plot(hypothesis(RT_m3.1$model,"conditionA > 0")) # intercept for arrow
plot(hypothesis(RT_m3.1$model,"conditionO > 0")) # intercept for other

plot(hypothesis(RT_m3.1$model,"conditionA:consistencyincon > 0")) # beta for consistency
plot(hypothesis(RT_m3.1$model,"conditionO:consistencyincon > 0")) # beta for consistency

plot(hypothesis(RT_m3.1$model, "conditionA > 0", class = "sd", group = "ID")) #varyig intercept for arrow
plot(hypothesis(RT_m3.1$model, "conditionO > 0", class = "sd", group = "ID")) #varyig intercept other
plot(hypothesis(RT_m3.1$model, "conditionA:consistencyincon > 0", class = "sd", group = "ID")) #varyig slope for arrow
plot(hypothesis(RT_m3.1$model, "conditionO:consistencyincon > 0", class = "sd", group = "ID")) #varyig slope other

#prior-posterior distributions
prior3 <- prior_samples(RT_m3$model)
post3 <- posterior_samples(RT_m3$model)

par(mfrow=c(1,1))

#prior-posterior plot for sigma
plot(density(prior3$sigma), ylim=c(0,40), lty = 3, main = "RT_M3: Posterior and prior distribution for sigma")
lines(density(post3$sigma), lty = 1)


```


#RT - Model Comparison
```{r}

#comparing out of sample error
loo_compare(RT_m0$model, RT_m1$model, RT_m1.1$model, RT_m3$model, RT_m3.1$model)

#RT_m2$model, RT_m2.1$model

#stacking weights
loo_model_weights(RT_m0$model, RT_m1.1$model, RT_m3.1$model)

```


#Error - Defining Models
```{r}

#from probability to log odds
#log(x) - log(1-x)
#can only go from 0 to 1 
logit(0.549834)
logit(0.999)
logit(0.268)
logit(0.5)
logit(0.)
inv_logit(1.5)


percE <- y %>% 
  group_by(ID) %>% 
  summarize(incorrect = length(which(accuracy == "incorrect")), 
            correct = length(which(accuracy == "correct")),
            ratio = incorrect/(correct+incorrect))

mean(percE$ratio)
max(percE$incorrect)
sd(percE$ratio)

### Multilevel Models
# Baseline model
E_f0 <- bf(accuracy ~ 1 + (1|ID))

# Consistency, simple varying effect
E_f1 <- bf(accuracy ~ 1 + consistency + (1|ID))
# Consistency, complex varying effect
E_f1.1 <- bf(accuracy ~ 1 + consistency + (1 + consistency|ID))

# Consistency + Condition, simple varying effect
E_f2 <- bf(accuracy ~ 1 + condition + consistency + (1|ID))
# Consistency + Condition, complex varying effect
E_f2.1 <- bf(accuracy ~ 1 + condition + consistency + (1 + condition + consistency|ID))

# Interaction, simple varying effect
E_f3 <- bf(accuracy ~ 0 + condition + condition : consistency + (1|ID))
# Interaction, complex varying effect
E_f3.1 <- bf(accuracy ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

```


#Error - F0 
```{r}
y$accuracybi <- as.integer(y$accuracy) - 1
y$accuracybi <- as.integer(y$accuracybi)

E_f0 <- bf(accuracybi ~ 1 + (1|ID))

get_prior(E_f0, y, family = bernoulli())

p <- inv_logit(rnorm(10000,-2,1) + rnorm(10000,0,1))
dens(p, adj=0.1 )

inv_logit(4)
inv_logit(2)


inv_logit(-2.5)
inv_logit(2)
inv_logit(1.5)

E_prior_f0 <- c(
  prior(normal(-2, 1.5), class = Intercept),
  prior(normal(0, 1.5), class = sd))

E_prior_m0 <- Error_Prior_Function(formula = E_f0, prior = E_prior_f0, data = y)
y_pred <- posterior_linpred(E_prior_m0$model)
dens(inv_logit(y_pred))

E_m0 <- Error_Model_Function(formula = E_f0, prior = E_prior_f0, data = y)

E_m0$summary
E_m0$mcmc_trace
E_m0$mcmc_ranktrace
E_m0$posterior_check
y_pred <- posterior_linpred(E_m0$model)
dens(inv_logit(y_pred))

prior <- prior_samples(E_m0$model)
post <- posterior_samples(E_m0$model)

par(mfrow=c(1,1))

#prior-posterior plot for sigma
plot(density(prior$Intercept), ylim=c(0,4), xlim=c(-4,4), lty = 3, main = "E_m0: Posterior and prior distribution for the intercept")
lines(density(post$b_Intercept), lty = 1)

plot(density(inv_logit(prior$Intercept)), ylim=c(0,70), lty = 3, main= "E_m0: Posterior and prior distribution for the intercept")
lines(density(inv_logit(post$b_Intercept)), lty = 1)

plot(hypothesis(E_m0$model, "Intercept > 0", class = "sd", group = "ID")) #varyig intercept for arrow

```


#Error - F1
```{r}
E_f1 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f1, y, family = bernoulli())

E_prior_f1 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m1 <- Error_Prior_Function(formula = E_f1, prior = E_prior_f1, data = y)
E_m1 <- Error_Model_Function(formula = E_f1, prior = E_prior_f1, data = y)

E_m1$summary
E_m1$mcmc_trace
E_m1$mcmc_ranktrace
E_m1$posterior_check

```


#Error - F1.1
```{r}
E_f1.1 <- bf(accuracy ~ 1 + consistency + (1|ID))

# same prior as in f1
E_prior_m1.1 <- Error_Prior_Function(formula = E_f1.1, prior = E_prior_f1, data = y)
E_m1.1 <- Error_Model_Function(formula = E_f1.1, prior = E_prior_f1, data = y)

E_m1.1$summary
E_m1.1$mcmc_trace
E_m1.1$mcmc_ranktrace
E_m1.1$posterior_check

```


#Error - F2
```{r}
E_f2 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f2, y, family = bernoulli())

E_prior_f2 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m2 <- Error_Prior_Function(formula = E_f2, prior = E_prior_f2, data = y)
E_m2 <- Error_Model_Function(formula = E_f2, prior = E_prior_f2, data = y)

E_m2$summary
E_m2$mcmc_trace
E_m2$mcmc_ranktrace
E_m2$posterior_check

```


#Error - F2.1
```{r}
E_f2.1 <- bf(accuracy ~ 1 + consistency + (1|ID))

# same prior as in f2
E_prior_m2.1 <- Error_Prior_Function(formula = E_f2.1, prior = E_prior_f2.1, data = y)
E_m2.1 <- Error_Model_Function(formula = E_f2.1, prior = E_prior_f2.1, data = y)

E_m2.1$summary
E_m2.1$mcmc_trace
E_m2.1$mcmc_ranktrace
E_m2.1$posterior_check

```


#Error - F3
```{r}
E_f3 <- bf(accuracy ~ 1 + consistency + (1|ID))

get_prior(E_f3, y, family = bernoulli())

E_prior_f3 <- c(
  prior(normal(0, 1.5), class = Intercept)
  #prior(normal(nn,nn), class = b)?
  )

E_prior_m3 <- Error_Prior_Function(formula = E_f3, prior = E_prior_f3, data = y)
E_m3 <- Error_Model_Function(formula = E_f3, prior = E_prior_f3, data = y)

E_m3$summary
E_m3$mcmc_trace
E_m3$mcmc_ranktrace
E_m3$posterior_check

```




#Error - F3.1
```{r}
E_f3.1 <- bf(accuracy ~ 0 + condition + condition : consistency + (0 + condition + condition : consistency|ID))

get_prior(E_f3.1, y, family = bernoulli())

E_prior_f3.1 <- c(
  prior(normal(-2, 1.5), class = b, coef = conditionA),
  prior(normal(-2, 1.5), class = b, coef = conditionO),
  prior(normal(0, 1.5), class = b, coef = conditionA:consistencyincon),
  prior(normal(0, 1.5), class = b, coef = conditionO:consistencyincon),
  prior(normal(0, 1.5), class = sd),
  prior(lkj(1), class = cor)
  # prior(normal(nn, nn), class = ndt))
)

# same prior as in f3
E_prior_m3.1 <- Error_Prior_Function(formula = E_f3.1, prior = E_prior_f3.1, data = y)
y_pred <- posterior_linpred(E_prior_m3.1$model)
dens(inv_logit(y_pred))

E_m3.1 <- Error_Model_Function(formula = E_f3.1, prior = E_prior_f3.1, data = y)

E_m3.1$summary
E_m3.1$mcmc_trace
E_m3.1$mcmc_ranktrace
E_m3.1$posterior_check

y_pred <- posterior_linpred(E_m3.1$model)
dens(inv_logit(y_pred))

prior <- prior_samples(E_m3.1$model)
post <- posterior_samples(E_m3.1$model)


plot(hypothesis(E_m3.1$model,"conditionA > 0")) # intercept for arrow
plot(hypothesis(E_m3.1$model,"conditionO > 0")) # intercept for other

plot(hypothesis(E_m3.1$model,"conditionA:consistencyincon > 0")) # beta for consistency
plot(hypothesis(E_m3.1$model,"conditionO:consistencyincon > 0")) # beta for consistency

plot(hypothesis(E_m3.1$model, "conditionA > 0", class = "sd", group = "ID")) #varyig intercept for arrow
plot(hypothesis(E_m3.1$model, "conditionO > 0", class = "sd", group = "ID")) #varyig intercept other
plot(hypothesis(E_m3.1$model, "conditionA:consistencyincon > 0", class = "sd", group = "ID")) #varyig slope for arrow
plot(hypothesis(E_m3.1$model, "conditionO:consistencyincon > 0", class = "sd", group = "ID")) #varyig slope other

plot(hypothesis(E_m3.1$model, "ID__conditionA__conditionO > 0", class = "cor")) #varyig intercept for arrow
plot(hypothesis(E_m3.1$model, "ID__conditionA__conditionA:consistencyincon > 0", class = "cor")) #varyig intercept for arrow
plot(hypothesis(E_m3.1$model, "ID__conditionA__conditionA:consistencyincon > 0", class = "cor"))

#real hypothesis testing 
plot(hypothesis(E_m3.1$model,"conditionO > conditionA"))
plot(hypothesis(E_m3.1$model,"conditionO:consistencyincon > conditionA:consistencyincon"))

```


#PLOTS PLOTS PLOTS
```{r}

ggplot(data = y, aes(x = cosistency, y = accuracy, color = condition)) + 
  geom_line()


```



#Error - Model Comparison
```{r}

#comparing out of sample error
loo_compare(E_m0, E_m1, E_m1.1, E_m2, E_m2.1, E_m3, E_m3.1)

#stacking weights
loo_model_weights(E_m0, E_m1, E_m1.1, E_m2, E_m2.1, E_m3, E_m3.1)

```


#Empathy
```{r}
#scale empathy! 
d$totalemp <- scale(d$totalemp)
d$cogemp <- scale(d$cogemp)
d$affemp <- scale(d$affemp)

#possible models
#total empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:totalemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:totalemp + (varying effects))

#cognitive empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:cogemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:cogemp + (varying effects))

#affective empathy
EmpRT_f <- bf(RT ~ 0 + condition + condition:consistency + condition:consistency:affemp + (varying effects))
EmpE_f <- bf(accuracy ~ 0 + condition + condition:consistency + condition:consistency:affemp + (varying effects))


#and only test one parameter
#conditionAvatar:Consistency1:Empathy
#conditionAvatar:Consistency1:Empathy > conditionArrows:Consistency1:Empathy


#other option: 
#extract posterior of varying effects from h1, for each participant you get n samples of the score for the slope of consistency within the avatar condition (you can ignore the other varying effects). You run a model predicting this score from the empathy score (making sure to tell the model that the different samples cluster under ID).

var_eff <- ranef(RT_m3.1$model, summary = F)

var_eff_m <- vareff ~ totalemp 

#bf(vareff ~ 1 + totalemp + (1|gr(ID, by = totalemp))
#bf(vareff ~ 0 + totalemp + (1|gr(ID, by = totalemp))



```

